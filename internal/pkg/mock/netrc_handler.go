// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: netrc_handler.go

package mock

import (
	sync "sync"

	github_com_confluentinc_cli_internal_pkg_netrc "github.com/confluentinc/cli/internal/pkg/netrc"
)

// MockNetrcHandler is a mock of NetrcHandler interface
type MockNetrcHandler struct {
	lockWriteNetrcCredentials sync.Mutex
	WriteNetrcCredentialsFunc func(cliName string, isSSO bool, ctxName, username, password string) error

	lockGetMatchingNetrcMachine sync.Mutex
	GetMatchingNetrcMachineFunc func(params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error)

	lockGetFileName sync.Mutex
	GetFileNameFunc func() string

	calls struct {
		WriteNetrcCredentials []struct {
			CliName  string
			IsSSO    bool
			CtxName  string
			Username string
			Password string
		}
		GetMatchingNetrcMachine []struct {
			Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams
		}
		GetFileName []struct {
		}
	}
}

// WriteNetrcCredentials mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) WriteNetrcCredentials(cliName string, isSSO bool, ctxName, username, password string) error {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	if m.WriteNetrcCredentialsFunc == nil {
		panic("mocker: MockNetrcHandler.WriteNetrcCredentialsFunc is nil but MockNetrcHandler.WriteNetrcCredentials was called.")
	}

	call := struct {
		CliName  string
		IsSSO    bool
		CtxName  string
		Username string
		Password string
	}{
		CliName:  cliName,
		IsSSO:    isSSO,
		CtxName:  ctxName,
		Username: username,
		Password: password,
	}

	m.calls.WriteNetrcCredentials = append(m.calls.WriteNetrcCredentials, call)

	return m.WriteNetrcCredentialsFunc(cliName, isSSO, ctxName, username, password)
}

// WriteNetrcCredentialsCalled returns true if WriteNetrcCredentials was called at least once.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalled() bool {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return len(m.calls.WriteNetrcCredentials) > 0
}

// WriteNetrcCredentialsCalls returns the calls made to WriteNetrcCredentials.
func (m *MockNetrcHandler) WriteNetrcCredentialsCalls() []struct {
	CliName  string
	IsSSO    bool
	CtxName  string
	Username string
	Password string
} {
	m.lockWriteNetrcCredentials.Lock()
	defer m.lockWriteNetrcCredentials.Unlock()

	return m.calls.WriteNetrcCredentials
}

// GetMatchingNetrcMachine mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetMatchingNetrcMachine(params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams) (*github_com_confluentinc_cli_internal_pkg_netrc.Machine, error) {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	if m.GetMatchingNetrcMachineFunc == nil {
		panic("mocker: MockNetrcHandler.GetMatchingNetrcMachineFunc is nil but MockNetrcHandler.GetMatchingNetrcMachine was called.")
	}

	call := struct {
		Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams
	}{
		Params: params,
	}

	m.calls.GetMatchingNetrcMachine = append(m.calls.GetMatchingNetrcMachine, call)

	return m.GetMatchingNetrcMachineFunc(params)
}

// GetMatchingNetrcMachineCalled returns true if GetMatchingNetrcMachine was called at least once.
func (m *MockNetrcHandler) GetMatchingNetrcMachineCalled() bool {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return len(m.calls.GetMatchingNetrcMachine) > 0
}

// GetMatchingNetrcMachineCalls returns the calls made to GetMatchingNetrcMachine.
func (m *MockNetrcHandler) GetMatchingNetrcMachineCalls() []struct {
	Params github_com_confluentinc_cli_internal_pkg_netrc.GetMatchingNetrcMachineParams
} {
	m.lockGetMatchingNetrcMachine.Lock()
	defer m.lockGetMatchingNetrcMachine.Unlock()

	return m.calls.GetMatchingNetrcMachine
}

// GetFileName mocks base method by wrapping the associated func.
func (m *MockNetrcHandler) GetFileName() string {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	if m.GetFileNameFunc == nil {
		panic("mocker: MockNetrcHandler.GetFileNameFunc is nil but MockNetrcHandler.GetFileName was called.")
	}

	call := struct {
	}{}

	m.calls.GetFileName = append(m.calls.GetFileName, call)

	return m.GetFileNameFunc()
}

// GetFileNameCalled returns true if GetFileName was called at least once.
func (m *MockNetrcHandler) GetFileNameCalled() bool {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return len(m.calls.GetFileName) > 0
}

// GetFileNameCalls returns the calls made to GetFileName.
func (m *MockNetrcHandler) GetFileNameCalls() []struct {
} {
	m.lockGetFileName.Lock()
	defer m.lockGetFileName.Unlock()

	return m.calls.GetFileName
}

// Reset resets the calls made to the mocked methods.
func (m *MockNetrcHandler) Reset() {
	m.lockWriteNetrcCredentials.Lock()
	m.calls.WriteNetrcCredentials = nil
	m.lockWriteNetrcCredentials.Unlock()
	m.lockGetMatchingNetrcMachine.Lock()
	m.calls.GetMatchingNetrcMachine = nil
	m.lockGetMatchingNetrcMachine.Unlock()
	m.lockGetFileName.Lock()
	m.calls.GetFileName = nil
	m.lockGetFileName.Unlock()
}
